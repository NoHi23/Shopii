{"ast":null,"code":"import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\nimport axios from 'axios';\nconst API_URL = process.env.REACT_APP_API_URL || 'http://localhost:9999/api';\n\n// Async thunk for fetching conversations\nexport const fetchConversations = createAsyncThunk('chat/fetchConversations', async (_, _ref) => {\n  let {\n    getState,\n    rejectWithValue\n  } = _ref;\n  try {\n    const token = getState().auth.token;\n    if (!token) {\n      return rejectWithValue('No token found');\n    }\n    const response = await axios.get(`${API_URL}/chat/conversations`, {\n      headers: {\n        Authorization: `Bearer ${token}`\n      }\n    });\n    return response.data.conversations;\n  } catch (error) {\n    var _error$response, _error$response$data;\n    return rejectWithValue(((_error$response = error.response) === null || _error$response === void 0 ? void 0 : (_error$response$data = _error$response.data) === null || _error$response$data === void 0 ? void 0 : _error$response$data.message) || 'Failed to fetch conversations');\n  }\n});\n\n// Async thunk for fetching messages in a conversation\nexport const fetchMessages = createAsyncThunk('chat/fetchMessages', async (conversationId, _ref2) => {\n  let {\n    getState,\n    rejectWithValue\n  } = _ref2;\n  try {\n    const token = getState().auth.token;\n    if (!token) {\n      return rejectWithValue('No token found');\n    }\n    const response = await axios.get(`${API_URL}/chat/conversations/${conversationId}/messages`, {\n      headers: {\n        Authorization: `Bearer ${token}`\n      }\n    });\n    return {\n      conversationId,\n      messages: response.data.messages\n    };\n  } catch (error) {\n    var _error$response2, _error$response2$data;\n    return rejectWithValue(((_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : (_error$response2$data = _error$response2.data) === null || _error$response2$data === void 0 ? void 0 : _error$response2$data.message) || 'Failed to fetch messages');\n  }\n});\n\n// Async thunk for starting a new conversation\nexport const startConversation = createAsyncThunk('chat/startConversation', async (userId, _ref3) => {\n  let {\n    getState,\n    rejectWithValue\n  } = _ref3;\n  try {\n    const token = getState().auth.token;\n    if (!token) {\n      return rejectWithValue('No token found');\n    }\n    const response = await axios.get(`${API_URL}/chat/conversations/user/${userId}`, {\n      headers: {\n        Authorization: `Bearer ${token}`\n      }\n    });\n    return response.data.conversation;\n  } catch (error) {\n    var _error$response3, _error$response3$data;\n    return rejectWithValue(((_error$response3 = error.response) === null || _error$response3 === void 0 ? void 0 : (_error$response3$data = _error$response3.data) === null || _error$response3$data === void 0 ? void 0 : _error$response3$data.message) || 'Failed to start conversation');\n  }\n});\nconst initialState = {\n  conversations: [],\n  activeConversation: null,\n  messages: {},\n  loading: false,\n  error: null,\n  onlineUsers: {},\n  typingUsers: {}\n};\nconst chatSlice = createSlice({\n  name: 'chat',\n  initialState,\n  reducers: {\n    setActiveConversation: (state, action) => {\n      state.activeConversation = action.payload;\n    },\n    addMessage: (state, action) => {\n      const {\n        conversationId,\n        message\n      } = action.payload;\n      if (!state.messages[conversationId]) {\n        state.messages[conversationId] = [];\n      }\n      state.messages[conversationId].push(message);\n\n      // Update the last message of the conversation\n      const conversationIndex = state.conversations.findIndex(conv => conv._id === conversationId);\n      if (conversationIndex !== -1) {\n        state.conversations[conversationIndex].lastMessage = message;\n\n        // Move this conversation to the top\n        const conversation = state.conversations[conversationIndex];\n        state.conversations.splice(conversationIndex, 1);\n        state.conversations.unshift(conversation);\n      }\n    },\n    markMessagesAsRead: (state, action) => {\n      const {\n        conversationId,\n        messageIds\n      } = action.payload;\n      if (state.messages[conversationId]) {\n        state.messages[conversationId] = state.messages[conversationId].map(message => messageIds.includes(message._id) ? {\n          ...message,\n          read: true\n        } : message);\n      }\n\n      // Update unread count for this conversation\n      const conversationIndex = state.conversations.findIndex(conv => conv._id === conversationId);\n      if (conversationIndex !== -1) {\n        state.conversations[conversationIndex].unreadCount = 0;\n      }\n    },\n    updateOnlineStatus: (state, action) => {\n      const {\n        userId,\n        status\n      } = action.payload;\n      state.onlineUsers[userId] = status === 'online';\n    },\n    updateTypingStatus: (state, action) => {\n      const {\n        userId,\n        conversationId,\n        isTyping\n      } = action.payload;\n      if (!state.typingUsers[conversationId]) {\n        state.typingUsers[conversationId] = {};\n      }\n      state.typingUsers[conversationId][userId] = isTyping;\n    },\n    incrementUnreadCount: (state, action) => {\n      const {\n        conversationId\n      } = action.payload;\n      const conversationIndex = state.conversations.findIndex(conv => conv._id === conversationId);\n      if (conversationIndex !== -1) {\n        const currentCount = state.conversations[conversationIndex].unreadCount || 0;\n        state.conversations[conversationIndex].unreadCount = currentCount + 1;\n      }\n    },\n    clearChatState: state => {\n      return initialState;\n    }\n  },\n  extraReducers: builder => {\n    builder\n    // Handle fetchConversations\n    .addCase(fetchConversations.pending, state => {\n      state.loading = true;\n      state.error = null;\n    }).addCase(fetchConversations.fulfilled, (state, action) => {\n      state.conversations = action.payload;\n      state.loading = false;\n    }).addCase(fetchConversations.rejected, (state, action) => {\n      state.error = action.payload;\n      state.loading = false;\n    })\n\n    // Handle fetchMessages\n    .addCase(fetchMessages.pending, state => {\n      state.loading = true;\n      state.error = null;\n    }).addCase(fetchMessages.fulfilled, (state, action) => {\n      const {\n        conversationId,\n        messages\n      } = action.payload;\n      state.messages[conversationId] = messages;\n      state.loading = false;\n\n      // Reset unread count\n      const conversationIndex = state.conversations.findIndex(conv => conv._id === conversationId);\n      if (conversationIndex !== -1) {\n        state.conversations[conversationIndex].unreadCount = 0;\n      }\n    }).addCase(fetchMessages.rejected, (state, action) => {\n      state.error = action.payload;\n      state.loading = false;\n    })\n\n    // Handle startConversation\n    .addCase(startConversation.pending, state => {\n      state.loading = true;\n      state.error = null;\n    }).addCase(startConversation.fulfilled, (state, action) => {\n      // Check if conversation already exists\n      const existingIndex = state.conversations.findIndex(conv => conv._id === action.payload._id);\n      if (existingIndex === -1) {\n        state.conversations.unshift(action.payload);\n      }\n      state.activeConversation = action.payload._id;\n      state.loading = false;\n    }).addCase(startConversation.rejected, (state, action) => {\n      state.error = action.payload;\n      state.loading = false;\n    });\n  }\n});\nexport const {\n  setActiveConversation,\n  addMessage,\n  markMessagesAsRead,\n  updateOnlineStatus,\n  updateTypingStatus,\n  incrementUnreadCount,\n  clearChatState\n} = chatSlice.actions;\nexport default chatSlice.reducer;","map":{"version":3,"names":["createSlice","createAsyncThunk","axios","API_URL","process","env","REACT_APP_API_URL","fetchConversations","_","getState","rejectWithValue","token","auth","response","get","headers","Authorization","data","conversations","error","message","fetchMessages","conversationId","messages","startConversation","userId","conversation","initialState","activeConversation","loading","onlineUsers","typingUsers","chatSlice","name","reducers","setActiveConversation","state","action","payload","addMessage","push","conversationIndex","findIndex","conv","_id","lastMessage","splice","unshift","markMessagesAsRead","messageIds","map","includes","read","unreadCount","updateOnlineStatus","status","updateTypingStatus","isTyping","incrementUnreadCount","currentCount","clearChatState","extraReducers","builder","addCase","pending","fulfilled","rejected","existingIndex","actions","reducer"],"sources":["D:/SU25/SDN302 - HOANNN/Shopii-Template/front-end/src/features/chat/chatSlice.js"],"sourcesContent":["import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\r\nimport axios from 'axios';\r\n\r\nconst API_URL = process.env.REACT_APP_API_URL || 'http://localhost:9999/api';\r\n\r\n// Async thunk for fetching conversations\r\nexport const fetchConversations = createAsyncThunk(\r\n  'chat/fetchConversations',\r\n  async (_, { getState, rejectWithValue }) => {\r\n    try {\r\n      const token = getState().auth.token;\r\n      if (!token) {\r\n        return rejectWithValue('No token found');\r\n      }\r\n      \r\n      const response = await axios.get(`${API_URL}/chat/conversations`, {\r\n        headers: { Authorization: `Bearer ${token}` }\r\n      });\r\n      \r\n      return response.data.conversations;\r\n    } catch (error) {\r\n      return rejectWithValue(error.response?.data?.message || 'Failed to fetch conversations');\r\n    }\r\n  }\r\n);\r\n\r\n// Async thunk for fetching messages in a conversation\r\nexport const fetchMessages = createAsyncThunk(\r\n  'chat/fetchMessages',\r\n  async (conversationId, { getState, rejectWithValue }) => {\r\n    try {\r\n      const token = getState().auth.token;\r\n      if (!token) {\r\n        return rejectWithValue('No token found');\r\n      }\r\n      \r\n      const response = await axios.get(\r\n        `${API_URL}/chat/conversations/${conversationId}/messages`,\r\n        { headers: { Authorization: `Bearer ${token}` } }\r\n      );\r\n      \r\n      return {\r\n        conversationId,\r\n        messages: response.data.messages\r\n      };\r\n    } catch (error) {\r\n      return rejectWithValue(error.response?.data?.message || 'Failed to fetch messages');\r\n    }\r\n  }\r\n);\r\n\r\n// Async thunk for starting a new conversation\r\nexport const startConversation = createAsyncThunk(\r\n  'chat/startConversation',\r\n  async (userId, { getState, rejectWithValue }) => {\r\n    try {\r\n      const token = getState().auth.token;\r\n      if (!token) {\r\n        return rejectWithValue('No token found');\r\n      }\r\n      \r\n      const response = await axios.get(\r\n        `${API_URL}/chat/conversations/user/${userId}`,\r\n        { headers: { Authorization: `Bearer ${token}` } }\r\n      );\r\n      \r\n      return response.data.conversation;\r\n    } catch (error) {\r\n      return rejectWithValue(error.response?.data?.message || 'Failed to start conversation');\r\n    }\r\n  }\r\n);\r\n\r\nconst initialState = {\r\n  conversations: [],\r\n  activeConversation: null,\r\n  messages: {},\r\n  loading: false,\r\n  error: null,\r\n  onlineUsers: {},\r\n  typingUsers: {}\r\n};\r\n\r\nconst chatSlice = createSlice({\r\n  name: 'chat',\r\n  initialState,\r\n  reducers: {\r\n    setActiveConversation: (state, action) => {\r\n      state.activeConversation = action.payload;\r\n    },\r\n    addMessage: (state, action) => {\r\n      const { conversationId, message } = action.payload;\r\n      if (!state.messages[conversationId]) {\r\n        state.messages[conversationId] = [];\r\n      }\r\n      state.messages[conversationId].push(message);\r\n      \r\n      // Update the last message of the conversation\r\n      const conversationIndex = state.conversations.findIndex(\r\n        conv => conv._id === conversationId\r\n      );\r\n      \r\n      if (conversationIndex !== -1) {\r\n        state.conversations[conversationIndex].lastMessage = message;\r\n        \r\n        // Move this conversation to the top\r\n        const conversation = state.conversations[conversationIndex];\r\n        state.conversations.splice(conversationIndex, 1);\r\n        state.conversations.unshift(conversation);\r\n      }\r\n    },\r\n    markMessagesAsRead: (state, action) => {\r\n      const { conversationId, messageIds } = action.payload;\r\n      \r\n      if (state.messages[conversationId]) {\r\n        state.messages[conversationId] = state.messages[conversationId].map(\r\n          message => messageIds.includes(message._id) \r\n            ? { ...message, read: true } \r\n            : message\r\n        );\r\n      }\r\n      \r\n      // Update unread count for this conversation\r\n      const conversationIndex = state.conversations.findIndex(\r\n        conv => conv._id === conversationId\r\n      );\r\n      \r\n      if (conversationIndex !== -1) {\r\n        state.conversations[conversationIndex].unreadCount = 0;\r\n      }\r\n    },\r\n    updateOnlineStatus: (state, action) => {\r\n      const { userId, status } = action.payload;\r\n      state.onlineUsers[userId] = status === 'online';\r\n    },\r\n    updateTypingStatus: (state, action) => {\r\n      const { userId, conversationId, isTyping } = action.payload;\r\n      \r\n      if (!state.typingUsers[conversationId]) {\r\n        state.typingUsers[conversationId] = {};\r\n      }\r\n      \r\n      state.typingUsers[conversationId][userId] = isTyping;\r\n    },\r\n    incrementUnreadCount: (state, action) => {\r\n      const { conversationId } = action.payload;\r\n      const conversationIndex = state.conversations.findIndex(\r\n        conv => conv._id === conversationId\r\n      );\r\n      \r\n      if (conversationIndex !== -1) {\r\n        const currentCount = state.conversations[conversationIndex].unreadCount || 0;\r\n        state.conversations[conversationIndex].unreadCount = currentCount + 1;\r\n      }\r\n    },\r\n    clearChatState: (state) => {\r\n      return initialState;\r\n    }\r\n  },\r\n  extraReducers: (builder) => {\r\n    builder\r\n      // Handle fetchConversations\r\n      .addCase(fetchConversations.pending, (state) => {\r\n        state.loading = true;\r\n        state.error = null;\r\n      })\r\n      .addCase(fetchConversations.fulfilled, (state, action) => {\r\n        state.conversations = action.payload;\r\n        state.loading = false;\r\n      })\r\n      .addCase(fetchConversations.rejected, (state, action) => {\r\n        state.error = action.payload;\r\n        state.loading = false;\r\n      })\r\n      \r\n      // Handle fetchMessages\r\n      .addCase(fetchMessages.pending, (state) => {\r\n        state.loading = true;\r\n        state.error = null;\r\n      })\r\n      .addCase(fetchMessages.fulfilled, (state, action) => {\r\n        const { conversationId, messages } = action.payload;\r\n        state.messages[conversationId] = messages;\r\n        state.loading = false;\r\n        \r\n        // Reset unread count\r\n        const conversationIndex = state.conversations.findIndex(\r\n          conv => conv._id === conversationId\r\n        );\r\n        \r\n        if (conversationIndex !== -1) {\r\n          state.conversations[conversationIndex].unreadCount = 0;\r\n        }\r\n      })\r\n      .addCase(fetchMessages.rejected, (state, action) => {\r\n        state.error = action.payload;\r\n        state.loading = false;\r\n      })\r\n      \r\n      // Handle startConversation\r\n      .addCase(startConversation.pending, (state) => {\r\n        state.loading = true;\r\n        state.error = null;\r\n      })\r\n      .addCase(startConversation.fulfilled, (state, action) => {\r\n        // Check if conversation already exists\r\n        const existingIndex = state.conversations.findIndex(\r\n          conv => conv._id === action.payload._id\r\n        );\r\n        \r\n        if (existingIndex === -1) {\r\n          state.conversations.unshift(action.payload);\r\n        }\r\n        \r\n        state.activeConversation = action.payload._id;\r\n        state.loading = false;\r\n      })\r\n      .addCase(startConversation.rejected, (state, action) => {\r\n        state.error = action.payload;\r\n        state.loading = false;\r\n      });\r\n  }\r\n});\r\n\r\nexport const {\r\n  setActiveConversation,\r\n  addMessage,\r\n  markMessagesAsRead,\r\n  updateOnlineStatus,\r\n  updateTypingStatus,\r\n  incrementUnreadCount,\r\n  clearChatState\r\n} = chatSlice.actions;\r\n\r\nexport default chatSlice.reducer; "],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}